version: '3.8'

services:
  backend-expert:
    build:
      context: ./backend-expert
      dockerfile: Dockerfile
    container_name: mcp-backend-expert
    environment:
      - DATABASE_URL=${DATABASE_URL:-postgresql://user:password@localhost:5432/db}
      - DATABASE_TYPE=${DATABASE_TYPE:-postgres}
      - NODE_ENV=production
    restart: unless-stopped
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "node", "-e", "console.log('healthy')"]
      interval: 30s
      timeout: 3s
      retries: 3

  frontend-expert:
    build:
      context: ./frontend-expert
      dockerfile: Dockerfile
    container_name: mcp-frontend-expert
    environment:
      - NODE_ENV=production
      - HEADLESS=${HEADLESS:-true}
    restart: unless-stopped
    networks:
      - mcp-network
    # Share X11 socket for non-headless mode (optional)
    # volumes:
    #   - /tmp/.X11-unix:/tmp/.X11-unix:rw
    # environment:
    #   - DISPLAY=${DISPLAY}
    healthcheck:
      test: ["CMD", "node", "-e", "console.log('healthy')"]
      interval: 30s
      timeout: 3s
      retries: 3

  devops-expert:
    build:
      context: ./devops-expert
      dockerfile: Dockerfile
    container_name: mcp-devops-expert
    environment:
      - DOCKER_HOST=${DOCKER_HOST:-unix:///var/run/docker.sock}
      - DEPLOY_COMMAND=${DEPLOY_COMMAND:-docker compose up -d}
      - COMPOSE_FILE=${COMPOSE_FILE:-docker-compose.yml}
      - SECRETS_PATH=${SECRETS_PATH:-/run/secrets}
      - NODE_ENV=production
    volumes:
      # Mount Docker socket for container management
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # Mount docker-compose files (optional)
      - ${PWD}:/workspace:ro
    restart: unless-stopped
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "node", "-e", "console.log('healthy')"]
      interval: 30s
      timeout: 3s
      retries: 3

  database-expert:
    build:
      context: ./database-expert
      dockerfile: Dockerfile
    container_name: mcp-database-expert
    environment:
      - DATABASE_URL=${DATABASE_URL:-postgresql://user:password@localhost:5432/db}
      - MYSQL_URL=${MYSQL_URL}
      - DATABASE_TYPE=${DATABASE_TYPE:-postgres}
      - NODE_ENV=production
    restart: unless-stopped
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "node", "-e", "console.log('healthy')"]
      interval: 30s
      timeout: 3s
      retries: 3

  infrastructure-expert:
    build:
      context: ./infrastructure-expert
      dockerfile: Dockerfile
    container_name: mcp-infrastructure-expert
    environment:
      - AWS_REGION=${AWS_REGION:-us-east-1}
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AWS_PROFILE=${AWS_PROFILE}
      - NODE_ENV=production
    # Mount AWS credentials (alternative to env vars)
    volumes:
      - ${HOME}/.aws:/home/mcp/.aws:ro
    restart: unless-stopped
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "node", "-e", "console.log('healthy')"]
      interval: 30s
      timeout: 3s
      retries: 3

networks:
  mcp-network:
    driver: bridge

# Optional: Add a PostgreSQL database for testing
# Uncomment to spin up a test database
#
# postgres:
#   image: postgres:14-alpine
#   container_name: mcp-test-postgres
#   environment:
#     - POSTGRES_USER=testuser
#     - POSTGRES_PASSWORD=testpass
#     - POSTGRES_DB=testdb
#   ports:
#     - "5432:5432"
#   volumes:
#     - postgres-data:/var/lib/postgresql/data
#   networks:
#     - mcp-network
#
# volumes:
#   postgres-data:
